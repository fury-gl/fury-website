<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <id>https://fury.gl/</id>
  <title>Blog - Posts by Tania Castillo</title>
  <updated>2024-07-30T20:15:31.569821+00:00</updated>
  <link href="https://fury.gl/"/>
  <link href="https://fury.gl/blog/author/tania-castillo/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.io/" version="0.11.10">ABlog</generator>
  <entry>
    <id>https://fury.gl/posts/2023/2023-08-24-week-12-tvcastillod.html</id>
    <title>Week 12 : Experimenting with ODFs implementation</title>
    <updated>2023-08-24T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-12-experimenting-with-odfs-implementation"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;There were different issues I needed to address for the ODF implementation. Even though I could not solve any of them completely, I did check each of the issues and made some progress. All the work in progress is being recorded in the following branch &lt;a class="reference external" href="https://github.com/tvcastillod/fury/tree/SH-for-ODF-impl"&gt;SH-for-ODF-impl&lt;/a&gt;, which when ready will be associated with a well-structured PR.&lt;/p&gt;
&lt;p&gt;First, about the scaling, I was suggested to check Generalized Fractional Anisotropy &lt;strong&gt;gfa&lt;/strong&gt; metric to adjust the scaling depending on the shape of the ODF glyph, i.e., the less the &lt;strong&gt;gfa&lt;/strong&gt; the more sphere-shaped and smaller, so I had to associate a greater scaling for those. However, this did not work very well as I was unable to define an appropriate scale relation that would give an equitable result for each glyph. For this reason, I opted to use peak values which are extracted from the ODFs, setting the scales as 1/peak_value*0.4 and I got a more uniformly sized glyph without the need of setting it manually. That is a temporal solution as I would like to see better why this happens and if possible do the adjustment inside the shader instead of a precalculation.&lt;/p&gt;
&lt;p&gt;Second, for the direction, I made a small adjustment to the spherical coordinates which affected the direction of the ODF glyph. As you can see below,&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/263122770-b9ee19d2-d82b-4d7f-a5bb-1cbbf5907049.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/263122770-b9ee19d2-d82b-4d7f-a5bb-1cbbf5907049.png" style="width: 400px;" /&gt;
&lt;p&gt;All the glyphs are aligned over the y-axis but not over the z-axis, to correct this I precalculated the main direction of each glyph using peaks and passed it to the shader as a &lt;em&gt;vec3&lt;/em&gt;, then used &lt;em&gt;vec2vecrotmat&lt;/em&gt; to align the main axis vector of the ODF to the required direction vector, the only problem with this is that not all the glyps are equally aligned to the axis, i.e., the first 3 glyphs are aligned with the x-axis but the last one is aligned with the y-axis, so the final rotation gives a different result for that one.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/263122752-b2aa696f-62a5-4b09-b8dd-0cb1ec49431c.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/263122752-b2aa696f-62a5-4b09-b8dd-0cb1ec49431c.png" style="width: 400px;" /&gt;
&lt;p&gt;As with the first small adjustment of the coordinates the direction was partially correct, I need to double check the theta, phi and r definitions to see if I can get the right direction without the need of the additional data of direction. Also, there might be a way to get the specific rotation angles associated to each individual glyph from the data associated with the ODFs.&lt;/p&gt;
&lt;p&gt;Third, about passing the coefficients data through textures, I understand better now how to pass textures to the shaders but I still have problems understanding how to retrieve the data inside the shader. I used &lt;a class="reference external" href="https://github.com/fury-gl/fury/blob/master/docs/experimental/viz_shader_texture.py"&gt;this base implementation&lt;/a&gt;, suggested by one of my mentors, to store the data as a &lt;a class="reference external" href="http://www.khronos.org/opengl/wiki/Cubemap_Texture#:~:text=A%20Cubemap%20Texture%20is%20a,the%20value%20to%20be%20accessed."&gt;texture cubemap&lt;/a&gt;, “a texture, where each mipmap level consists of six 2D images which must be square. The 6 images represent the faces of a cube”. I had 4x15 coefficients and inside the function, a grid of RGB colors is made so then it can be mapped as a texture. To check if was passing the data correctly, I used the same value, .5, for all the textures, so then I could pick a random texel get a specific color (gray), and pass it as &lt;em&gt;fragOutput0&lt;/em&gt; to see if the value was correct. However, it didn’t appear to work correctly as I couldn’t get the expected color. To get the specific color I used &lt;a class="reference external" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/texture.xhtml"&gt;texture(sampler, P)&lt;/a&gt; which samples texels from the texture bound to sampler at texture coordinate P. Now, what I still need to figure out is which should be the corresponding texture coordinate. I have tried with random coordinates, as they are supposed to correspond to a point on the cube and since the information I have encoded in the texture is all the same, I assumed that I would get the expected result for any set of values. It might be a problem with the data normalization, or maybe there is something failing on the texture definition, but I need to review it in more detail to see where is the problem.&lt;/p&gt;
&lt;p&gt;Lastly, about the colormapping, I created the texture based on a generic colormap from &lt;a class="reference external" href="https://matplotlib.org/stable/tutorials/colors/colormaps.html"&gt;matplotlib&lt;/a&gt;. I was able to give some color to the glyph but it does not match correctly its shape. Some adjustment must be done regarding the texels, as the colormap is mapped on a cube, but I need it to fit the shape of the glyph correctly.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/263122760-7d1fff5e-7787-473c-8053-ea69f3009fb4.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/263122760-7d1fff5e-7787-473c-8053-ea69f3009fb4.png" style="width: 250px;" /&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I will continue to explore more on how to handle textures so I can solve the issues related to the coefficient data and colormapping. Also, take a deeper look at the SH implementation and check what is the information needed to adjust the main direction of the ODF correctly.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;As I mentioned I had some drawbacks in understanding the use of textures and how to retrieve the data inside the shaders. This is a topic that might take some time to manage properly but if I can master it and understand it better, it is a tool that can be useful later. Additionally, there are details of the SH implementation that I still need to understand and explore better in order to make sure I get exactly the same result as the current &lt;em&gt;odf_slicer&lt;/em&gt; implementation.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-08-24-week-12-tvcastillod.html"/>
    <summary>There were different issues I needed to address for the ODF implementation. Even though I could not solve any of them completely, I did check each of the issues and made some progress. All the work in progress is being recorded in the following branch SH-for-ODF-impl, which when ready will be associated with a well-structured PR.</summary>
    <category term="google" label="google"/>
    <published>2023-08-24T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-08-24-final-report-tvcastillod.html</id>
    <title>Google Summer of Code Final Work Product</title>
    <updated>2023-08-24T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;a class="reference external image-reference" href="https://summerofcode.withgoogle.com/programs/2023/projects/ymwnLwtT"&gt;&lt;img alt="https://developers.google.com/open-source/gsoc/resources/downloads/GSoC-logo-horizontal.svg" class="align-center" src="https://developers.google.com/open-source/gsoc/resources/downloads/GSoC-logo-horizontal.svg" style="height: 50px;" /&gt;
&lt;/a&gt;
&lt;a class="reference external image-reference" href="https://summerofcode.withgoogle.com/programs/2023/organizations/python-software-foundation"&gt;&lt;img alt="https://www.python.org/static/community_logos/python-logo.png" src="https://www.python.org/static/community_logos/python-logo.png" style="width: 40%;" /&gt;
&lt;/a&gt;
&lt;a class="reference external image-reference" href="https://fury.gl/latest/index.html"&gt;&lt;img alt="https://python-gsoc.org/logos/FURY.png" src="https://python-gsoc.org/logos/FURY.png" style="width: 25%;" /&gt;
&lt;/a&gt;
&lt;section id="google-summer-of-code-final-work-product"&gt;

&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; Tania Castillo&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Organisation:&lt;/strong&gt; Python Software Foundation&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sub-Organisation:&lt;/strong&gt; FURY&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Project:&lt;/strong&gt; &lt;a class="reference external" href="https://github.com/fury-gl/fury/wiki/Google-Summer-of-Code-2023-(GSOC2023)#project-3-sdf-based-uncertainty-representation-for-dmri-glyphs"&gt;SDF-based uncertainty representation for dMRI glyphs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="abstract"&gt;
&lt;h2&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Diffusion Magnetic Resonance Imaging (dMRI) is a non-invasive imaging technique used by neuroscientists to measure the diffusion of water molecules in biological tissue. The directional information is reconstructed using either a Diffusion Tensor Imaging (DTI) or High Angular Resolution Diffusion Imaging (HARDI) based model, which is graphically represented as tensors and Orientation Distribution Functions (ODF). Traditional rendering engines discretize Tensor and ODF surfaces using triangles or quadrilateral polygons, making their visual quality depending on the number of polygons used to build the 3D mesh, which might compromise real-time display performance. This project proposes a methodological approach to further improve the visualization of DTI tensors and HARDI ODFs glyphs by using well-established techniques in the field of computer graphics, such as geometry amplification, billboarding, signed distance functions (SDFs), and ray marching.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="proposed-objectives"&gt;
&lt;h2&gt;Proposed Objectives&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Implement a parallelized version of computer-generated billboards using geometry shaders for amplification.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Model the mathematical functions that express the geometry of ellipsoid glyphs and implement them using Ray Marching techniques.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Model the mathematical functions that express the geometry of ODF glyphs and implement them using Ray Marching techniques.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use SDF properties and techniques to represent the uncertainty of dMRI reconstruction models.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="objectives-completed"&gt;
&lt;h2&gt;Objectives Completed&lt;/h2&gt;
&lt;section id="ellipsoid-actor-implemented-with-sdf"&gt;
&lt;h3&gt;Ellipsoid actor implemented with SDF&lt;/h3&gt;
&lt;p&gt;A first approach for tensor glyph generation has been made, using ray marching and SDF applied to a box. The current implementation (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tensor_slicer&lt;/span&gt;&lt;/code&gt;) requires a sphere with a specific number of vertices to be deformed. Based on this model, a sphere with more vertices is needed to get a higher resolution. Because the ray marching technique does not use polygonal meshes, it is possible to define perfectly smooth surfaces and still obtain a fast rendering.&lt;/p&gt;
&lt;p&gt;Details of the implementation:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Vertex shader pre-calculations&lt;/em&gt;: Some minor calculations are done in the vertex shader. One, corresponding to the eigenvalues constraining and min-max normalization, are to avoid incorrect visualizations when the difference between the eigenvalues is too large. And the other is related to the tensor matrix calculation given by the diffusion tensor definition &lt;span class="math notranslate nohighlight"&gt;\(T = R^{−1}\Lambda R\)&lt;/span&gt;, where &lt;span class="math notranslate nohighlight"&gt;\(R\)&lt;/span&gt; is a rotation matrix that transforms the standard basis onto the eigenvector basis, and &lt;span class="math notranslate nohighlight"&gt;\(\Lambda\)&lt;/span&gt; is the diagonal matrix of eigenvalues &lt;a class="footnote-reference brackets" href="#id10" id="id1" role="doc-noteref"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;4&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Ellipsoid SDF definition&lt;/em&gt;: The definition of the SDF is done in the fragment shader inside the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;map&lt;/span&gt;&lt;/code&gt; function, which is used later for the ray marching algorithm and the normals calculation. We define the SDF more simply by transforming a sphere into an ellipsoid, considering that the SDF of a sphere is easily computed and the definition of a tensor gives us a linear transformation of a given geometry. Also, as scaling is not a rigid body transformation, we multiply the final result by a factor to compensate for the difference, which gave us the SDF of the ellipsoid defined as &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sdSphere(tensorMatrix&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt; &lt;span class="pre"&gt;(position&lt;/span&gt; &lt;span class="pre"&gt;-&lt;/span&gt; &lt;span class="pre"&gt;centerMCVSOutput),&lt;/span&gt; &lt;span class="pre"&gt;scaleVSOutput*0.48)&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt; &lt;span class="pre"&gt;scFactor&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Ray marching algorithm and lighting&lt;/em&gt;: For the ray marching algorithm, a small value of 20 was taken as the maximum distance since we apply the technique to each individual object and not all at the same time. Additionally, we set the convergence precision to 0.001. We use the central differences method to compute the normals necessary for the scene’s illumination, besides the Blinn-Phong lighting technique, which is high-quality and computationally cheap.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Visualization example&lt;/em&gt;: Below is a detailed visualization of the ellipsoids created from this new implementation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/244503195-a626718f-4a13-4275-a2b7-6773823e553c.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/244503195-a626718f-4a13-4275-a2b7-6773823e553c.png" style="width: 376px;" /&gt;
&lt;p&gt;This implementation does show a better quality in the displayed glyphs, and supports the display of a large amount of data, as seen in the image below. For this reason, a tutorial was made to justify in more detail the value of this new implementation. Below are some images generated for the tutorial.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/260906510-d422e7b4-3ba3-4de6-bfd0-09c04bec8876.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/260906510-d422e7b4-3ba3-4de6-bfd0-09c04bec8876.png" style="width: 600px;" /&gt;
&lt;p&gt;&lt;em&gt;Pull Requests:&lt;/em&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ellipsoid actor implemented with SDF (Merged)&lt;/strong&gt; &lt;a class="github reference external" href="https://github.com/fury-gl/fury/pull/791"&gt;fury-gl/fury#791&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tutorial on using ellipsoid actor to visualize tensor ellipsoids for DTI (Merged)&lt;/strong&gt; &lt;a class="github reference external" href="https://github.com/fury-gl/fury/pull/818"&gt;fury-gl/fury#818&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Future work:&lt;/strong&gt; In line with one of the initial objectives, it is expected to implement billboards later on to improve the performance, i.e., higher frame rate and less memory usage for the tensor ellipsoid creation. In addition to looking for ways to optimize the naive ray marching algorithm and the definition of SDFs.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="objectives-in-progress"&gt;
&lt;h2&gt;Objectives in Progress&lt;/h2&gt;
&lt;section id="dti-uncertainty-visualization"&gt;
&lt;h3&gt;DTI uncertainty visualization&lt;/h3&gt;
&lt;p&gt;The DTI visualization pipeline is fairly complex, as a level of uncertainty arises, which, if visualized, helps to assess the model’s accuracy. This measure is not currently implemented, and even though there are several methods to calculate and visualize the uncertainty in the DTI model, because of its simplicity and visual representation, we considered Matrix Perturbation Analysis (MPA) proposed by Basser &lt;a class="footnote-reference brackets" href="#id7" id="id2" role="doc-noteref"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;1&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/a&gt;. This measurement is visualized as double cones representing the variance of the main direction of diffusion, for which the ray marching technique was also used to create these objects.&lt;/p&gt;
&lt;p&gt;Details of the implementation:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Source of uncertainty&lt;/em&gt;: The method of MPA arises from the susceptibility of DTI to dMRI noise present in diffusion-weighted images (DWIs), and also because the model is inherently statistical, making the tensor estimation and other derived quantities to be random variables &lt;a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;1&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/a&gt;. For this reason, this method focus on the premise that image noise produces a random perturbation in the diffusion tensor estimation, and therefore in the calculation of eigenvalues and eigenvectors, particularly in the first eigenvector associated with the main diffusion direction.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Mathematical equation&lt;/em&gt;: The description of the perturbation of the principal eigenvector is given by math formula where &lt;span class="math notranslate nohighlight"&gt;\(\Delta D\)&lt;/span&gt; corresponds to the estimated perturbation matrix of &lt;span class="math notranslate nohighlight"&gt;\(D\)&lt;/span&gt; given by the diagonal elements of the covariance matrix &lt;span class="math notranslate nohighlight"&gt;\(\Sigma_{\alpha} \approx (B^T\Sigma^{−1}_{e}B)^{−1}\)&lt;/span&gt;, where &lt;span class="math notranslate nohighlight"&gt;\(\Sigma_{e}\)&lt;/span&gt; is the covariance matrix of the error e, defined as a diagonal matrix made with the diagonal elements of &lt;span class="math notranslate nohighlight"&gt;\((\Sigma^{−1}_{e}) = ⟨S(b)⟩^2 / \sigma^{2}_{\eta}\)&lt;/span&gt;. Then, to get the angle &lt;span class="math notranslate nohighlight"&gt;\(\theta\)&lt;/span&gt; between the perturbed principal eigenvector of &lt;span class="math notranslate nohighlight"&gt;\(D\)&lt;/span&gt;, &lt;span class="math notranslate nohighlight"&gt;\(\varepsilon_1 + \Delta\varepsilon_1\)&lt;/span&gt;, and the estimated eigenvector &lt;span class="math notranslate nohighlight"&gt;\(\varepsilon_1\)&lt;/span&gt;, it can be approximated by &lt;span class="math notranslate nohighlight"&gt;\(\theta = \tan^{−1}( \| \Delta\varepsilon_1 \|)\)&lt;/span&gt; &lt;a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;2&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/a&gt;. Taking into account the above, we define the function &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;main_dir_uncertainty(evals,&lt;/span&gt; &lt;span class="pre"&gt;evecs,&lt;/span&gt; &lt;span class="pre"&gt;signal,&lt;/span&gt; &lt;span class="pre"&gt;sigma,&lt;/span&gt; &lt;span class="pre"&gt;b_matrix)&lt;/span&gt;&lt;/code&gt; that calculates the uncertainty of the eigenvector associated to the main direction of diffusion.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Double cone SDF definition&lt;/em&gt;: The final SDF is composed by the union of 2 separately cones using the definition taken from this list of &lt;a class="reference external" href="https://iquilezles.org/articles/distfunctions/#:~:text=Cone%20%2D%20exact,sign(s)%3B%0A%7D"&gt;distance functions&lt;/a&gt;, in this way we have the SDF for the double cone defined as &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;opUnion(sdCone(p,a,h),&lt;/span&gt; &lt;span class="pre"&gt;sdCone(-p,a,h))&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt; &lt;span class="pre"&gt;scaleVSOutput&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Visualization example&lt;/em&gt;: Below is a demo of how this new feature is intended to be used, an image of diffusion tensor ellipsoids and their associated uncertainty cones.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/254747296-09a8674e-bfc0-4b3f-820f-8a1b1ad8c5c9.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/254747296-09a8674e-bfc0-4b3f-820f-8a1b1ad8c5c9.png" style="width: 610px;" /&gt;
&lt;p&gt;The implementation is almost complete, but as it is a new addition that includes mathematical calculations and for which there is no direct reference for comparison, it requires a more detail review before it can be incorporated.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pull Request:&lt;/em&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DTI uncertainty visualization (Under Review)&lt;/strong&gt; &lt;a class="github reference external" href="https://github.com/fury-gl/fury/pull/810"&gt;fury-gl/fury#810&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Future work:&lt;/strong&gt; A tutorial will be made explaining in more detail how to calculate the parameters needed for the uncertainty cones using &lt;strong&gt;DIPY&lt;/strong&gt; functions, specifically: &lt;a class="reference external" href="https://github.com/dipy/dipy/blob/321e06722ef42b5add3a7f570f6422845177eafa/dipy/denoise/noise_estimate.py#L272"&gt;estimate_sigma&lt;/a&gt; for the noise variance calculation, &lt;a class="reference external" href="https://github.com/dipy/dipy/blob/321e06722ef42b5add3a7f570f6422845177eafa/dipy/reconst/dti.py#L2112"&gt;design_matrix&lt;/a&gt; to get the b-matrix, and &lt;a class="reference external" href="https://github.com/dipy/dipy/blob/321e06722ef42b5add3a7f570f6422845177eafa/dipy/reconst/dti.py#L639"&gt;tensor_prediction&lt;/a&gt; for the signal estimation. Additionally, when the ODF implementation is complete, uncertainty for this other reconstruction model is expected to be added, using semitransparent glyphs representing the mean directional information proposed by Tournier &lt;a class="footnote-reference brackets" href="#id9" id="id5" role="doc-noteref"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;3&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="odf-actor-implemented-with-sdf"&gt;
&lt;h3&gt;ODF actor implemented with SDF&lt;/h3&gt;
&lt;p&gt;HARDI-based techniques require more images than DTI, however, they model the diffusion directions as probability distribution functions (PDFs), and the fitted values are returned as orientation distribution functions (ODFs). ODFs are more diffusion sensitive than the diffusion tensor and, therefore, can determine the structure of multi-directional voxels very common in the white matter regions of the brain &lt;a class="footnote-reference brackets" href="#id9" id="id6" role="doc-noteref"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;3&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/a&gt;. The current actor to display this kind of glyphs is the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;odf_slicer&lt;/span&gt;&lt;/code&gt; which, given an array of spherical harmonics (SH) coefficients renders a grid of ODFs, which are created from a sphere with a specific number of vertices that fit the data.&lt;/p&gt;
&lt;p&gt;For the application of this model using the same SDF ray marching techniques, we need the data of the SH coefficients, which are used to calculate the orientation distribution function (ODF) described &lt;a class="reference external" href="https://dipy.org/documentation/1.7.0/theory/sh_basis/"&gt;here&lt;/a&gt;. Different SH bases can be used, but for this first approach we focus on &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;descoteaux07&lt;/span&gt;&lt;/code&gt; (as labeled in DIPY). After performing the necessary calculations, we obtain an approximate result of the current implementation of FURY, as seen below.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/260909561-fd90033c-018a-465b-bd16-3586bb31ca36.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/260909561-fd90033c-018a-465b-bd16-3586bb31ca36.png" style="width: 580px;" /&gt;
&lt;p&gt;With a first implementation we start to solve some issues related to direction, color, and data handling, to obtain exactly the same results as the current implementation.&lt;/p&gt;
&lt;p&gt;Details on the issues:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;The direction and the scaling&lt;/em&gt;: When the shape of the ODF is more sphere-like, the size of the glyph is smaller, so for the moment it needs to be adjusted manually, but the idea is to find a relationship between the coefficients and the final object size so it can be automatically scaled. Additionally, as seen in the image, the direction does not match. To fix this, an adjustment in the calculation of the spherical coordinates can be made, or pass the direction information directly.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Pass the coefficients data efficiently&lt;/em&gt;: I’m currently creating one actor per glyph since I’m using a &lt;em&gt;uniform&lt;/em&gt; array to pass the coefficients, but the idea is to pass all the data simultaneously. The first idea is to encode the coefficients data through a texture and retrieve them in the fragment shader.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;The colormapping and the lighting&lt;/em&gt;: As these objects present curvatures with quite a bit of detail in some cases, this requires more specific lighting work, in addition to having now not only one color but a color map. This can also be done with texture, but it is necessary to see in more detail how to adjust the texture to the glyph’s shape.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More details on current progress can be seen in blogpost of &lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-08-16-week-11-tvcastillod.html"&gt;week 11&lt;/a&gt; and &lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-08-24-week-12-tvcastillod.html"&gt;week 12&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Working branch:&lt;/em&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ODF implementation (Under Development)&lt;/strong&gt;
&lt;a class="github reference external" href="https://github.com/tvcastillod/fury/tree/SH-for-ODF-impl"&gt;tvcastillod/fury&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="gsoc-weekly-blogs"&gt;
&lt;h2&gt;GSoC Weekly Blogs&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;My blog posts can be found on the &lt;a class="reference external" href="https://fury.gl/latest/blog/author/tania-castillo.html"&gt;FURY website&lt;/a&gt; and the &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/"&gt;Python GSoC blog&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="timeline"&gt;
&lt;h2&gt;Timeline&lt;/h2&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr class="row-odd"&gt;&lt;th class="head"&gt;&lt;p&gt;Date&lt;/p&gt;&lt;/th&gt;
&lt;th class="head"&gt;&lt;p&gt;Description&lt;/p&gt;&lt;/th&gt;
&lt;th class="head"&gt;&lt;p&gt;Blog Post Link&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 0(02-06-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Community Bounding Period&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-06-02-week-0-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-0-2"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;Week 1(05-06-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Ellipsoid actor implemented with SDF&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-06-05-week-1-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-1-23"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 2(12-06-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Making adjustments to the Ellipsoid Actor&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-06-12-week-2-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-2-18"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;Week 3(19-06-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Working on uncertainty and details of the first PR&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-06-19-week-3-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-3-27"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 4(27-06-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;First draft of the DTI uncertainty visualization&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-06-27-week-4-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-4-24"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;Week 5(03-07-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Preparing the data for the Ellipsoid tutorial&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-07-03-week-5-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-5-27"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 6(10-07-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;First draft of the Ellipsoid tutorial&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-07-10-week-6-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-6-26"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;Week 7(17-07-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Adjustments on the Uncertainty Cones visualization&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-07-17-week-7-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-7-26"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 8(25-07-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Working on Ellipsoid Tutorial and exploring SH&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-07-25-week-8-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-8-17"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;Week 9(31-07-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Tutorial done and polishing DTI uncertainty&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-07-31-week-9-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-9-22"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 10(08-08-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Start of SH implementation experiments&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-08-08-week-10-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-10-16"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-odd"&gt;&lt;td&gt;&lt;p&gt;Week 11(16-08-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Adjusting ODF implementation and looking for solutions on issues found&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-08-16-week-11-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-11-17"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="row-even"&gt;&lt;td&gt;&lt;p&gt;Week 12(24-08-2022)&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;Experimenting with ODFs implementation&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;a class="reference external" href="https://fury.gl/latest/posts/2023/2023-08-24-week-12-tvcastillod.html"&gt;FURY&lt;/a&gt; - &lt;a class="reference external" href="https://blogs.python-gsoc.org/en/tvcastillods-blog/weekly-check-in-12-9"&gt;Python&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/section&gt;
&lt;section id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;aside class="footnote-list brackets"&gt;
&lt;aside class="footnote brackets" id="id7" role="doc-footnote"&gt;
&lt;span class="label"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;1&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="backrefs"&gt;(&lt;a role="doc-backlink" href="#id2"&gt;1&lt;/a&gt;,&lt;a role="doc-backlink" href="#id3"&gt;2&lt;/a&gt;)&lt;/span&gt;
&lt;p&gt;Basser, P. J. (1997). Quantifying errors in fiber direction and diffusion tensor field maps resulting from MR noise. In 5th Scientific Meeting of the ISMRM (Vol. 1740).&lt;/p&gt;
&lt;/aside&gt;
&lt;aside class="footnote brackets" id="id8" role="doc-footnote"&gt;
&lt;span class="label"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;&lt;a role="doc-backlink" href="#id4"&gt;2&lt;/a&gt;&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;Chang, L. C., Koay, C. G., Pierpaoli, C., &amp;amp; Basser, P. J. (2007). Variance of estimated DTI‐derived parameters via first‐order perturbation methods. Magnetic Resonance in Medicine: An Official Journal of the International Society for Magnetic Resonance in Medicine, 57(1), 141-149.&lt;/p&gt;
&lt;/aside&gt;
&lt;aside class="footnote brackets" id="id9" role="doc-footnote"&gt;
&lt;span class="label"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;3&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span class="backrefs"&gt;(&lt;a role="doc-backlink" href="#id5"&gt;1&lt;/a&gt;,&lt;a role="doc-backlink" href="#id6"&gt;2&lt;/a&gt;)&lt;/span&gt;
&lt;p&gt;J-Donald Tournier, Fernando Calamante, David G Gadian, and Alan Connelly. Direct estimation of the fiber orientation density function from diffusion-weighted mri data using spherical deconvolution. Neuroimage, 23(3):1176–1185, 2004.&lt;/p&gt;
&lt;/aside&gt;
&lt;aside class="footnote brackets" id="id10" role="doc-footnote"&gt;
&lt;span class="label"&gt;&lt;span class="fn-bracket"&gt;[&lt;/span&gt;&lt;a role="doc-backlink" href="#id1"&gt;4&lt;/a&gt;&lt;span class="fn-bracket"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;Gordon Kindlmann. Superquadric tensor glyphs. In Proceedings of the Sixth Joint Eurographics-IEEE TCVG conference on Visualization, pages 147–154, 2004.&lt;/p&gt;
&lt;/aside&gt;
&lt;/aside&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-08-24-final-report-tvcastillod.html"/>
    <summary>Name: Tania Castillo</summary>
    <category term="google" label="google"/>
    <published>2023-08-24T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-08-16-week-11-tvcastillod.html</id>
    <title>Week 11 : Adjusting ODF implementation and looking for solutions on issues found</title>
    <updated>2023-08-16T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-11-adjusting-odf-implementation-and-looking-for-solutions-on-issues-found"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;I continued to experiment with the ODF glyph implementation. Thanks to one of my mentors I figured out how to get the missing data corresponding to the SH coefficients &lt;span class="math notranslate nohighlight"&gt;\(a^l_m\)&lt;/span&gt; part of the function &lt;span class="math notranslate nohighlight"&gt;\(f(\theta, \phi)\)&lt;/span&gt; described &lt;a class="reference external" href="https://dipy.org/documentation/1.7.0/theory/sh_basis/"&gt;here&lt;/a&gt;. I also was told to make sure to implement the correct SH basis since there are different definitions from the literature, I have to focus now in the one proposed by Descoteaux, described in &lt;a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1002/mrm.21277"&gt;this paper&lt;/a&gt;, which is labeled in &lt;em&gt;DIPY&lt;/em&gt; as &lt;em&gt;descoteaux07&lt;/em&gt;. To do this I had to make a small adjustment to the base implementation that I took as a reference, from which I obtained a first result using SH of order 4.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/260909561-fd90033c-018a-465b-bd16-3586bb31ca36.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/260909561-fd90033c-018a-465b-bd16-3586bb31ca36.png" style="width: 600px;" /&gt;
&lt;p&gt;It appears that the results on the shape are about the same, except for the direction, but there is still work to be done.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;For now, there are 3 things I will continue to work on:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The color and lighting. As these objects present curvatures with quite a bit of detail in some cases, this is something that requires more specific lighting work, in addition to having now not only one color but a color map.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The scaling. This is something I still don’t know how to deal with. I had to adjust it manually for now, but the idea is to find a relationship between the coefficients and the final object size so it can be automatically scaled, or maybe there is a proper way to pre-process this data before passing it to the shaders to get the right result at once.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How to pass the information of the coefficients efficiently. Right now I’m creating one actor per glyph since I’m using a uniform array to pass the coefficients, but the idea is to pass all the data at once. I found several ideas &lt;a class="reference external" href="https://stackoverflow.com/questions/7954927/passing-a-list-of-values-to-fragment-shader"&gt;ideas here&lt;/a&gt; of how to pass a list of values to the fragment shader directly, I just need to explore deeper how this can be done on &lt;strong&gt;FURY&lt;/strong&gt;, and see which option is most suitable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;All the points mentioned above are things that I tried to fix, however, it is something that I need to look at in much more detail and that I know is going to take me some time to understand and test before I get to the expected result. I hope to get some ideas from my mentors and fellow GSoC contributors on how I can proceed to deal with each of the problems.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-08-16-week-11-tvcastillod.html"/>
    <summary>I continued to experiment with the ODF glyph implementation. Thanks to one of my mentors I figured out how to get the missing data corresponding to the SH coefficients a^l_m part of the function f(\theta, \phi) described here. I also was told to make sure to implement the correct SH basis since there are different definitions from the literature, I have to focus now in the one proposed by Descoteaux, described in this paper, which is labeled in DIPY as descoteaux07. To do this I had to make a small adjustment to the base implementation that I took as a reference, from which I obtained a first result using SH of order 4.</summary>
    <category term="google" label="google"/>
    <published>2023-08-16T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-08-08-week-10-tvcastillod.html</id>
    <title>Week 10 : Start of SH implementation experiments</title>
    <updated>2023-08-08T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-10-start-of-sh-implementation-experiments"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;I started formally working on SH implementation. I was told to start first doing a simple program where I can modify in real-time the order &lt;span class="math notranslate nohighlight"&gt;\(l\)&lt;/span&gt; and degree &lt;span class="math notranslate nohighlight"&gt;\(m\)&lt;/span&gt;, parameters corresponding to the &lt;a class="reference external" href="https://dipy.org/documentation/1.7.0/theory/sh_basis/"&gt;Spherical Harmonics function&lt;/a&gt; &lt;span class="math notranslate nohighlight"&gt;\(Y^m_l(\theta,\phi)=\)&lt;/span&gt;, based on &lt;a class="reference external" href="https://github.com/lenixlobo/fury/commit/2b7ce7a71fd422dc5a250d7b49e1eea2db9d3bce"&gt;previous work&lt;/a&gt;. That is just one part of the final ODF calculation, but here is what a first experimental script looks like.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/260910073-10b0edd4-40e3-495c-85ad-79993aef3b19.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/260910073-10b0edd4-40e3-495c-85ad-79993aef3b19.png" style="width: 600px;" /&gt;
&lt;p&gt;I did it in order to make sure it was visually correct and also to understand better how those 2 parameters are related and need to be incorporated into the final calculation. There is one issue at first sight that needs to be addressed, and that is the scaling, since for SH with a degree near 0, the object gets out of bounds.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I will keep polishing details from my current open PRs, hopefully, I will get another PR merged before the last GSoC week.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;Not sure about how to use the current implementation I have to get similar visualizations made with &lt;em&gt;odf_slicer&lt;/em&gt;, since the parameters that the function receive are different, so I need to take a deeper look and see where it might be the connection or if I should make some adjustments on the parameters.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-08-08-week-10-tvcastillod.html"/>
    <summary>I started formally working on SH implementation. I was told to start first doing a simple program where I can modify in real-time the order l and degree m, parameters corresponding to the Spherical Harmonics function Y^m_l(\theta,\phi)=, based on previous work. That is just one part of the final ODF calculation, but here is what a first experimental script looks like.</summary>
    <category term="google" label="google"/>
    <published>2023-08-08T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-07-31-week-9-tvcastillod.html</id>
    <title>Week 9: Tutorial done and polishing DTI uncertainty</title>
    <updated>2023-07-31T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-9-tutorial-done-and-polishing-dti-uncertainty"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;I addressed the comments from the tutorial of &lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/818"&gt;PR #818&lt;/a&gt;  related to how to display specific visualizations I wanted to make. I was suggested to use &lt;em&gt;ShowManager&lt;/em&gt; to handle the zoom of the scene and also to use &lt;em&gt;GridUI&lt;/em&gt; to display several actors at the same time for a visual quality comparison of the tensors. Below are some images generated for the tutorial that is almost done.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/260906510-d422e7b4-3ba3-4de6-bfd0-09c04bec8876.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/260906510-d422e7b4-3ba3-4de6-bfd0-09c04bec8876.png" style="width: 600px;" /&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;There are some issues with the tests of the uncertainty implementation, specifically a segmentation problem that has to be with the shaders, so I expect to correct the problem by next week.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;I’m still thinking about how to approach the implementation of the spherical harmonics for ODF glyphs. Most of the implementations I have found are static so my task would be to try to parametrize the existing functions, so I can pass data from Python to the shaders properly so that I can obtain the same result as the current &lt;em&gt;odf_slicer&lt;/em&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-07-31-week-9-tvcastillod.html"/>
    <summary>I addressed the comments from the tutorial of PR #818  related to how to display specific visualizations I wanted to make. I was suggested to use ShowManager to handle the zoom of the scene and also to use GridUI to display several actors at the same time for a visual quality comparison of the tensors. Below are some images generated for the tutorial that is almost done.</summary>
    <category term="google" label="google"/>
    <published>2023-07-31T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-07-25-week-8-tvcastillod.html</id>
    <title>Week 8: Working on Ellipsoid Tutorial and exploring SH</title>
    <updated>2023-07-25T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-8-working-on-ellipsoid-tutorial-and-exploring-sh"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;I mainly worked on the ellipsoid actor tutorial, as &lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/791"&gt;PR #791&lt;/a&gt; is finally merged, so I was able to complete the tutorial by adding my implementation. In addition, during the weekly meeting, I received a good overview of the next issue I will be working on, which is using raymarching SDFs to display spherical harmonics (SH) for visualizing ODF glyphs for DTI. I got several ideas and resources which I can start experimenting with, such as &lt;a class="reference external" href="https://www.shadertoy.com/results?query=Spherical+Harmonics"&gt;Shadertoy&lt;/a&gt; and some base implementations from other FURY contributors. The main drawback when creating these objects is the amount of data required to create them, because depending on the SH order, the number of parameters that the function receives may vary, also unlike the tensors, which are represented only with a 3x3 matrix, here we could have more than 9 values associated with a single glyph, so passing the information from python to the shaders is not so trivial, besides requiring more resources as there is more information that needs to be processed. Some ideas I received were using matrixes instead of vectors, using templating, or even using texture to pass the data. I started to explore these options further, as well as to review in more detail the existing implementations of SH with raymarching, in order to understand them better.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I currently have two PRs under review, so I will address the comments I receive and update them accordingly. I also will continue to explore and start working on the implementation of these objects so that I can start making adjustments and further discuss possible improvements to the implementation I will make.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;Fortunately, I did not encounter any drawbacks this week.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-07-25-week-8-tvcastillod.html"/>
    <summary>I mainly worked on the ellipsoid actor tutorial, as PR #791 is finally merged, so I was able to complete the tutorial by adding my implementation. In addition, during the weekly meeting, I received a good overview of the next issue I will be working on, which is using raymarching SDFs to display spherical harmonics (SH) for visualizing ODF glyphs for DTI. I got several ideas and resources which I can start experimenting with, such as Shadertoy and some base implementations from other FURY contributors. The main drawback when creating these objects is the amount of data required to create them, because depending on the SH order, the number of parameters that the function receives may vary, also unlike the tensors, which are represented only with a 3x3 matrix, here we could have more than 9 values associated with a single glyph, so passing the information from python to the shaders is not so trivial, besides requiring more resources as there is more information that needs to be processed. Some ideas I received were using matrixes instead of vectors, using templating, or even using texture to pass the data. I started to explore these options further, as well as to review in more detail the existing implementations of SH with raymarching, in order to understand them better.</summary>
    <category term="google" label="google"/>
    <published>2023-07-25T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-07-17-week-7-tvcastillod.html</id>
    <title>Week 7: Adjustments on the Uncertainty Cones visualization</title>
    <updated>2023-07-17T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-7-adjustments-on-the-uncertainty-cones-visualization"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;I was told to refactor some parts of the uncertainty PR, since I was relying too much on &lt;strong&gt;DIPY&lt;/strong&gt; functions which is not good because it makes maintenance more difficult as &lt;strong&gt;DIPY&lt;/strong&gt; requires &lt;strong&gt;FURY&lt;/strong&gt; for some functionalities. So I did some adjustments on the uncertainty function parameters and the corresponding tests, hopefully I managed to get with the most appropriate definition but I need to receive a first feedback to see how much I have to adjust the implementation. As I had to delete some relevant code lines inside the uncertainty calculation which consisted of preprocessing the data in order to define the necessary variables for the uncertainty formula, I was also suggested to make a tutorial of this new feature, so I can explain in detail how to obtain and adjust the necessary information, before passing it to the actor, and in general how and what is the purpose of this new function.&lt;/p&gt;
&lt;p&gt;I also continued working on the ellipsoid tutorial, which I hope to finish this week so that I can ask for a first revision.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I will finish defining some details of the tutorial so that it is ready for review, and now I will start working on the tutorial related to the uncertainty, while I receive feedback on the other PRs. Also, as preparation for the next step I will start exploring on how to address visualization of spherical harmonics for ODF glyphs visualization, I found that a previous GSoC participant at FURY started working on that and also did several work with raymarching and SDF (&lt;a href="#id1"&gt;&lt;span class="problematic" id="id2"&gt;:doc:`here is a summary of the work &amp;lt;../2020/2020-08-24-final-work-lenix&amp;gt;`_&lt;/span&gt;&lt;/a&gt;), so I will take a deeper look on that to see if I can get something useful I can start with.&lt;/p&gt;
&lt;aside class="system-message" id="id1"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;span class="docutils literal"&gt;/home/runner/work/fury/fury/docs/source/posts/2023/2023-07-17-week-7-tvcastillod.rst&lt;/span&gt;, line 19); &lt;em&gt;&lt;a href="#id2"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Mismatch: both interpreted text role prefix and reference suffix.&lt;/p&gt;
&lt;/aside&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;Not this week, but I foresee some problems with the uncertainty PR, we will see how it goes.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-07-17-week-7-tvcastillod.html"/>
    <summary>I was told to refactor some parts of the uncertainty PR, since I was relying too much on DIPY functions which is not good because it makes maintenance more difficult as DIPY requires FURY for some functionalities. So I did some adjustments on the uncertainty function parameters and the corresponding tests, hopefully I managed to get with the most appropriate definition but I need to receive a first feedback to see how much I have to adjust the implementation. As I had to delete some relevant code lines inside the uncertainty calculation which consisted of preprocessing the data in order to define the necessary variables for the uncertainty formula, I was also suggested to make a tutorial of this new feature, so I can explain in detail how to obtain and adjust the necessary information, before passing it to the actor, and in general how and what is the purpose of this new function.</summary>
    <category term="google" label="google"/>
    <published>2023-07-17T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-07-10-week-6-tvcastillod.html</id>
    <title>Week 6: First draft of the Ellipsoid tutorial</title>
    <updated>2023-07-10T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-6-first-draft-of-the-ellipsoid-tutorial"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/818"&gt;#PR 818: Tutorial on using ellipsoid actor to visualize tensor ellipsoids for DTI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I created the PR for the tutorial that will show the use that can be made of the &lt;em&gt;ellipsoid&lt;/em&gt; actor in the visualization of diffusion tensor ellipsoids. It is still in its most basic stage, but the structure that I have thought of for now consists of: displaying a slice using &lt;em&gt;tensor_slicer&lt;/em&gt; with spheres of 100, 200, and 724 vertices, and using &lt;em&gt;ellipsoid&lt;/em&gt; actor, and show a comparison of the visual quality of the tensor ellipsoids. Then, display a ROI using both actors and a whole brain using the &lt;em&gt;ellipsoid&lt;/em&gt; actor, to show that this new actor gives the possibility to display more data.&lt;/p&gt;
&lt;p&gt;I also submitted the &lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/810"&gt;uncertainty PR&lt;/a&gt; for review, in order to start making the necessary corrections.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I need &lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/791"&gt;#PR 791&lt;/a&gt; to be merged first, but meanwhile, I will start working on the explanation of the tutorial, since I already have the code structure and the idea of what I want to illustrate. I will discuss further work with my mentors at the upcoming meeting, so I can organize myself better and plan how I’m going to address the pending parts of my project.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;I found no major difficulties this week.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-07-10-week-6-tvcastillod.html"/>
    <summary>#PR 818: Tutorial on using ellipsoid actor to visualize tensor ellipsoids for DTI</summary>
    <category term="google" label="google"/>
    <published>2023-07-10T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-07-03-week-5-tvcastillod.html</id>
    <title>Week 5: Preparing the data for the Ellipsoid tutorial</title>
    <updated>2023-07-03T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-5-preparing-the-data-for-the-ellipsoid-tutorial"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;During the weekly meeting with my mentors, there was a small discussion over the naming of the actor and its usage. On the one hand, although the purpose of the actor is to visualize diffusion tensor ellipsoids, the idea is that it can also be used for any other type of visualization that requires the use of ellipsoids, so in the end, we decided to keep the name &lt;em&gt;ellipsoid&lt;/em&gt; as it is more generic. On the other hand, as there is already an actor made for the purpose of tensor visualization, namely &lt;a class="reference external" href="https://github.com/fury-gl/fury/blob/e595bad0246899d58d24121dcc291eb050721f9f/fury/actor.py#L1172"&gt;tensor_slicer&lt;/a&gt;, it might not be obvious how and why one would use this new ellipsoid actor for this purpose, thus it was proposed to make a tutorial that can clarify this. The main difference between both actors relies on the quality and the amount of data that can be displayed, so the idea is to show the difference between both alternatives so the user can choose which one to use depending on their needs. To prepare the tutorial the first step was to &lt;a class="reference external" href="https://github.com/fury-gl/fury-data/pull/12"&gt;add the data&lt;/a&gt; I will use on &lt;a class="reference external" href="https://github.com/fury-gl/fury-data"&gt;fury-data&lt;/a&gt; so I can then fetch and load the datasets I need to work on the tutorial.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I need &lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/791"&gt;#PR 791&lt;/a&gt; to be reviewed by my GSoC fellows at FURY, so I will address their comments, and additionally make adjustments on &lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/810"&gt;#PR 810&lt;/a&gt; based on the feedback I receive. I will also start working on the tutorial, the idea is to show the use that can be made of the ellipsoid actor in the visualization of diffusion tensor ellipsoids, compared to the &lt;em&gt;tensor_slicer&lt;/em&gt; actor. I plan to create a WIP PR to start getting feedback on the general structure of the tutorial and the way everything will be explained.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;I did not encounter any obstacles this week.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-07-03-week-5-tvcastillod.html"/>
    <summary>During the weekly meeting with my mentors, there was a small discussion over the naming of the actor and its usage. On the one hand, although the purpose of the actor is to visualize diffusion tensor ellipsoids, the idea is that it can also be used for any other type of visualization that requires the use of ellipsoids, so in the end, we decided to keep the name ellipsoid as it is more generic. On the other hand, as there is already an actor made for the purpose of tensor visualization, namely tensor_slicer, it might not be obvious how and why one would use this new ellipsoid actor for this purpose, thus it was proposed to make a tutorial that can clarify this. The main difference between both actors relies on the quality and the amount of data that can be displayed, so the idea is to show the difference between both alternatives so the user can choose which one to use depending on their needs. To prepare the tutorial the first step was to add the data I will use on fury-data so I can then fetch and load the datasets I need to work on the tutorial.</summary>
    <category term="google" label="google"/>
    <published>2023-07-03T00:00:00+00:00</published>
  </entry>
  <entry>
    <id>https://fury.gl/posts/2023/2023-06-27-week-4-tvcastillod.html</id>
    <title>Week 4: First draft of the DTI uncertainty visualization</title>
    <updated>2023-06-27T00:00:00+00:00</updated>
    <author>
      <name>Tania Castillo</name>
    </author>
    <content type="html">&lt;section id="week-4-first-draft-of-the-dti-uncertainty-visualization"&gt;

&lt;section id="what-did-i-do-this-week"&gt;
&lt;h2&gt;What did I do this week?&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/fury-gl/fury/pull/810"&gt;#PR 810: DTI uncertainty visualization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I made a second PR with the implementation of DTI uncertainty calculation and visualization. Below is an image of diffusion tensor ellipsoids and their associated uncertainty cones.&lt;/p&gt;
&lt;img alt="https://user-images.githubusercontent.com/31288525/254747296-09a8674e-bfc0-4b3f-820f-8a1b1ad8c5c9.png" class="align-center" src="https://user-images.githubusercontent.com/31288525/254747296-09a8674e-bfc0-4b3f-820f-8a1b1ad8c5c9.png" style="width: 530px;" /&gt;
&lt;p&gt;I had to use some &lt;strong&gt;DIPY&lt;/strong&gt; functions, specifically: &lt;a class="reference external" href="https://github.com/dipy/dipy/blob/321e06722ef42b5add3a7f570f6422845177eafa/dipy/denoise/noise_estimate.py#L272"&gt;estimate_sigma&lt;/a&gt; for the noise variance calculation, &lt;a class="reference external" href="https://github.com/dipy/dipy/blob/321e06722ef42b5add3a7f570f6422845177eafa/dipy/reconst/dti.py#L2112"&gt;design_matrix&lt;/a&gt; to get the b-matrix, and &lt;a class="reference external" href="https://github.com/dipy/dipy/blob/321e06722ef42b5add3a7f570f6422845177eafa/dipy/reconst/dti.py#L639"&gt;tensor_prediction&lt;/a&gt; for the signal estimation. The details of this calculations can be found &lt;a class="reference external" href="https://onlinelibrary.wiley.com/doi/full/10.1002/mrm.21111"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-coming-up-next"&gt;
&lt;h2&gt;What is coming up next?&lt;/h2&gt;
&lt;p&gt;I will continue working on the uncertainty PR which is still in its early stage, I’m going to make a couple of adjustments to the description of the parameters and the actor, and keep working on based on the feedback I receive. There are also minor details to be discussed with my mentors about the first PR, which I hope to finish refining.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="did-i-get-stuck-anywhere"&gt;
&lt;h2&gt;Did I get stuck anywhere?&lt;/h2&gt;
&lt;p&gt;It took me a while to make the PR because I had some problems with the uncertainty function definition. I tried to use the least amount of parameters for the function, since with data, bvals and bvecs it is possible to obtain the rest of the parameters needed to generate the cones, which led me to readjust some calculations from the base implementation I had, to keep everything working correctly.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://fury.gl/posts/2023/2023-06-27-week-4-tvcastillod.html"/>
    <summary>#PR 810: DTI uncertainty visualization</summary>
    <category term="google" label="google"/>
    <published>2023-06-27T00:00:00+00:00</published>
  </entry>
</feed>
